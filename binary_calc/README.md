## 求二进制最右为1的位是第几位

脏标记法可能会用到位表来记录标记.

假设有1024个数据. `SomeStruct data[1024];`

如果采用原始方法, 需要一个布尔数组 `bool dirty[1024];` 共占用1024字节.

如果采用位表, `unsigned char dirty[1024/8];` 会节省8倍的空间. 128字节.

问题就在于, 如何从 `标记位` 转换成对应的 `数据编号`.

- 0000 0001B -> 1
- 0000 0010B -> 2
- 0000 0100B -> 3
- 0000 1000B -> 4

当第k位(k在[0, 7]之间)标记, 该值就是 2^k, 为了避免使用函数库的 pow/sqrt, 这里直接可以用一个简单的映射表解决.

```c++
std::map<int, int> mark2idx = {
    {1, 0}, {2, 1}, {4, 2}, {8, 3},
    {16, 4}, {32, 5}, {64, 6}, {128, 7},
};
```

最后的问题在于, 我们如何把标记的一连串数值, 规整为 2^k

```c++
mark = x & (-x);        // 注意x是有符号整数: 反码, 就是按位取反再+1
// 或者
mark = x & (~(x)+1);
```

消去最右边的1

```c++
x = x & (x-1);
```